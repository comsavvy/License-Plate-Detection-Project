\documentclass[12pt,a4paper]{article}
\usepackage{geometry}
\usepackage{setspace}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{titlesec}
\usepackage{hyperref}
\usepackage{array}
\usepackage{amsfonts}
\usepackage{amssymb}

\geometry{margin=1in}
\setstretch{1.2}
\titleformat{\section}{\large\bfseries}{\thesection.}{1em}{}
\titleformat{\subsection}{\normalsize\bfseries}{\thesubsection.}{1em}{}

\lstset{
    basicstyle=\ttfamily\small,
    backgroundcolor=\color{gray!5},
    frame=single,
    breaklines=true,
    keywordstyle=\color{blue},
    commentstyle=\color{gray},
    showstringspaces=false
}

\title{Project Report:\\Senegalese License Plate Detection System}
\author{
    \textbf{Group 11}\\[0.8em]
    \begin{tabular}{c}
        Alliance IRIGENERA (Group Leader)\\
        Maryam Yahya MOHAMED\\
        Olusola Timothy OGUNDEPO\\
        Jean Baptiste HABINEZA
    \end{tabular}
}
\date{\today}

\begin{document}
\maketitle

\tableofcontents
\newpage

\section*{Abstract}
This project develops a Python-based system for detecting Senegalese vehicle license plate patterns within unstructured text documents. The implementation presents two complementary approaches: a manual character-by-character parser and a regular expression-based detector. Both methods support the standard Senegalese license plate formats, handle flexible separators (hyphens or spaces), and perform case-insensitive matching while ensuring standardized output formatting. The system achieves high precision with zero false positives in comprehensive testing scenarios, making it suitable for automated document processing and data extraction applications.

\section{Introduction}
\subsection{Problem Statement}
In many document processing scenarios, there is a need to extract structured information such as license plate numbers from unstructured text sources. This could include processing traffic reports, insurance documents, or administrative records where license plates are mentioned alongside other textual content.

\subsection{Project Objectives}
This project demonstrates two distinct approaches to solving the license plate detection problem for Senegalese vehicle plates:
\begin{enumerate}
    \item \textbf{Manual Parsing Approach}: A step-by-step algorithmic solution that explicitly handles each validation rule
    \item \textbf{Regular Expression Approach}: A pattern-matching solution that encodes the same rules in a compact regex pattern
\end{enumerate}

\subsection{Key Features}
\begin{itemize}
    \item Support for standard Senegalese license plate formats
    \item Flexible separator handling (hyphens and spaces)
    \item Case-insensitive input processing
    \item Standardized output formatting
    \item Duplicate detection and elimination
    \item Boundary validation to prevent false matches
\end{itemize}
\newpage
\section{License Plate Format Specification}
\subsection{Valid Formats}
Senegalese license plates follow two standardized patterns, where letters represent A–Z and digits represent 0–9:

\begin{center}
\begin{tabular}{|c|l|}
\hline
\textbf{Format} & \textbf{Description} \\
\hline
\texttt{XY-1234-T} & Two letters, four digits, one letter \\
\texttt{XY-1234-ZT} & Two letters, four digits, two letters \\
\hline
\end{tabular}
\end{center}

\subsection{Separator Flexibility}
The system accepts both hyphen (-) and single space separators:
\begin{itemize}
    \item \texttt{XY-1234-T} (hyphen-separated)
    \item \texttt{XY 1234 T} (space-separated)
\end{itemize}

\subsection{Validation Rules}
\begin{enumerate}
    \item \textbf{First segment}: Exactly two alphabetic characters (A-Z)
    \item \textbf{First separator}: Single hyphen (-) or single space ( )
    \item \textbf{Second segment}: Exactly four numeric digits (0-9)
    \item \textbf{Second separator}: Single hyphen (-) or single space ( )
    \item \textbf{Third segment}: One or two alphabetic characters (A-Z)
    \item \textbf{Boundary conditions}: No alphanumeric characters directly adjacent
    \item \textbf{Case handling}: Input is case-insensitive, output is uppercase
    \item \textbf{Normalization}: Output always uses hyphen separators
\end{enumerate}

\subsection{Pattern Examples}
\subsubsection{Valid Patterns}
\begin{lstlisting}[frame=single, backgroundcolor=\color{green!10}]
ab-1234-e      ->  AB-1234-E
AB 5678 CD     ->  AB-5678-CD
mn-4321-zt     ->  MN-4321-ZT
UV 9876 t      ->  UV-9876-T
\end{lstlisting}

\subsubsection{Invalid Patterns}
\begin{lstlisting}[frame=single, backgroundcolor=\color{red!10}]
AAB-1234-T     (three starting letters)
AB-12345-T     (five digits)
AB_1234_T      (underscore separators)
AB-1234-TXQ    (three ending letters)
1A-1234-T      (digit in first segment)
AB-123A-T      (letter in digit segment)
\end{lstlisting}

\section{System Requirements and Design Goals}
\subsection{Functional Requirements}
\begin{itemize}
    \item \textbf{Pattern Detection}: Identify all valid license plate patterns in input text
    \item \textbf{Format Standardization}: Convert all detected plates to uppercase with hyphen separators
    \item \textbf{Duplicate Handling}: Report each unique plate only once, preserving order of first appearance
    \item \textbf{Error Handling}: Provide informative messages when no plates are found
    \item \textbf{Boundary Validation}: Ensure detected patterns are complete plates, not substrings
\end{itemize}

\subsection{Non-Functional Requirements}
\begin{itemize}
    \item \textbf{Clarity}: Code should be readable and well-documented
    \item \textbf{Maintainability}: Easy to modify and extend for new patterns
    \item \textbf{Performance}: Efficient processing of text documents
    \item \textbf{Reliability}: Zero false positives in detection
    \item \textbf{Portability}: No external library dependencies (for manual approach)
\end{itemize}

\subsection{Design Philosophy}
The project implements two complementary approaches to demonstrate different programming paradigms:
\begin{itemize}
    \item \textbf{Explicit Algorithm}: Manual parsing for educational clarity and easy customization
    \item \textbf{Pattern Matching}: Regular expressions for concise and efficient processing
\end{itemize}

\section{Implementation Approach 1: Manual Character-by-Character Parsing}
\subsection{Algorithm Overview}
The manual parsing approach implements an explicit state machine that examines each character position in the input text. This method provides complete transparency in the validation process and allows for easy modification of detection rules.

\subsection{Core Algorithm Logic}
The algorithm follows these sequential steps for each character position:

\begin{enumerate}
    \item \textbf{Text Preprocessing}: Convert input text to uppercase for uniform processing
    \item \textbf{Position Scanning}: Iterate through each character position in the text
    \item \textbf{Pattern Validation}: At each position, attempt to match the license plate pattern:
    \begin{itemize}
        \item Verify two consecutive letters
        \item Check for valid separator (hyphen or space)
        \item Validate four consecutive digits
        \item Check for second valid separator
        \item Extract one or two trailing letters
    \end{itemize}
    \item \textbf{Boundary Checking}: Ensure the pattern is not part of a larger alphanumeric sequence
    \item \textbf{Normalization}: Convert valid matches to standard format (uppercase with hyphens)
    \item \textbf{Duplicate Prevention}: Store unique plates only, maintaining order of appearance
\end{enumerate}

\subsection{Detailed Implementation Steps}
\begin{enumerate}
    \item \textbf{Initialize}: Create empty list for storing detected plates
    \item \textbf{Scan}: For each character position $i$ in the text:
    \begin{itemize}
        \item Check if remaining text length is sufficient for minimum pattern
        \item Validate first two characters are letters
        \item Validate first separator character
        \item Validate next four characters are digits
        \item Validate second separator character
        \item Extract final letter(s) and validate count (1 or 2)
        \item Perform boundary validation
        \item If all validations pass, normalize and store the plate
        \item Advance position past the matched pattern
    \end{itemize}
    \item \textbf{Output}: Return list of unique plates in order of discovery
\end{enumerate}

\subsection{Algorithm Pseudocode}
\begin{lstlisting}[language=Python, caption=Manual Parsing Algorithm]
    def senegalese_plate_number_detector(text):
        UPPER = text uppercased
        plates = empty list
        i = 0
        while i < length - minimal_length:
        if next 2 chars not letters: i++ ; continue
        if next sep not '-' or ' ': i++ ; continue
        if next 4 chars not digits: i++ ; continue
        if next sep not '-' or ' ': i++ ; continue
        read 1 or 2 letters as end_part
        if none: i++ ; continue
        check boundary before and after
        if ok:
            plate = canonical form with hyphens
            store if new
            i = end of match
        else:
            i++
        if plates empty: report none else print list
\end{lstlisting}

\subsection{Advantages and Disadvantages}
\begin{center}
\begin{tabular}{|p{0.45\textwidth}|p{0.45\textwidth}|}
\hline
\textbf{Advantages} & \textbf{Disadvantages} \\
\hline
Complete algorithmic transparency & Higher code complexity \\
Easy to debug and modify & More verbose implementation \\
No external dependencies & Potentially slower execution \\
Educational value for understanding parsing & Requires more maintenance \\
Fine-grained control over validation & More prone to implementation errors \\
\hline
\end{tabular}
\end{center}

\section{Implementation Approach 2: Regular Expression Pattern Matching}
\subsection{Regular Expression Overview}
The regex-based approach encapsulates all validation rules into a single pattern string, leveraging the built-in pattern matching capabilities of Python's \texttt{re} module. This method provides a concise and efficient solution for license plate detection.

\subsection{Regex Pattern Construction}
The complete regular expression pattern is:
\begin{lstlisting}[language=Python, frame=single]
pattern = r'(?i)(?<![A-Z0-9])([A-Z]{2})[- ](\d{4})[- ]([A-Z]{1,2})(?![A-Z0-9])'
\end{lstlisting}

\subsection{Pattern Component Analysis}
\begin{center}
\begin{tabular}{|l|p{0.6\textwidth}|}
\hline
\textbf{Component} & \textbf{Function} \\
\hline
\texttt{(?i)} & Case-insensitive matching flag \\
\texttt{(?<![A-Z0-9])} & Negative lookbehind: ensures no alphanumeric character precedes \\
\texttt{([A-Z]\{2\})} & Capture group 1: exactly two letters \\
\texttt{[- ]} & Character class: hyphen or space separator \\
\texttt{(\textbackslash{}d\{4\})} & Capture group 2: exactly four digits \\
\texttt{[- ]} & Character class: hyphen or space separator \\
\texttt{([A-Z]\{1,2\})} & Capture group 3: one or two letters \\
\texttt{(?![A-Z0-9])} & Negative lookahead: ensures no alphanumeric character follows \\
\hline
\end{tabular}
\end{center}

\subsection{Advantages and Disadvantages}
\begin{center}
\begin{tabular}{|p{0.45\textwidth}|p{0.45\textwidth}|}
\hline
\textbf{Advantages} & \textbf{Disadvantages} \\
\hline
Concise and readable code & Less transparent validation logic \\
Highly optimized execution & Requires regex knowledge \\
Built-in pattern matching & More difficult to debug \\
Industry-standard approach & Pattern syntax can be complex \\
Fewer lines of code & Less educational for beginners \\
\hline
\end{tabular}
\end{center}

\section{Critical Implementation Details}
\subsection{Boundary Condition Management}
Proper boundary validation is essential to prevent false positives. The system must distinguish between valid standalone license plates and similar patterns embedded within larger alphanumeric sequences.

\subsubsection{Boundary Validation Logic}
\begin{itemize}
    \item \textbf{Left Boundary}: Character immediately before the pattern (if any) must not be alphanumeric
    \item \textbf{Right Boundary}: Character immediately after the pattern (if any) must not be alphanumeric
    \item \textbf{Edge Cases}: Patterns at the beginning or end of text are considered valid
    \item \textbf{Separator Characters}: Punctuation, whitespace, and special characters serve as valid boundaries
\end{itemize}

\subsubsection{Example Boundary Scenarios}
\begin{lstlisting}[frame=single, backgroundcolor=\color{blue!10}]
Valid: "License AB-1234-C was issued"     (space boundaries)
Valid: "(AB-1234-C)"                      (punctuation boundaries)
Valid: "AB-1234-C."                       (end boundary)
Invalid: "NAB-1234-CD"                    (embedded in larger sequence)
Invalid: "AB-1234-CDE"                    (embedded in larger sequence)
\end{lstlisting}

\subsection{Pattern Normalization and Storage}
\subsubsection{Normalization Process}
Upon successful pattern validation, the system performs standardization:
\begin{enumerate}
    \item \textbf{Case Conversion}: All alphabetic characters converted to uppercase
    \item \textbf{Separator Standardization}: All separators converted to hyphens
    \item \textbf{Format Consistency}: Final output follows \texttt{XX-DDDD-X(X)} pattern
\end{enumerate}

\subsubsection{Duplicate Management}
The storage mechanism implements several key features:
\begin{itemize}
    \item \textbf{Order Preservation}: Maintains sequence of first appearance in source text
    \item \textbf{Uniqueness Enforcement}: Each distinct plate appears only once in results
    \item \textbf{Efficient Lookup}: Uses list membership checking for duplicate detection
    \item \textbf{Memory Optimization}: Stores only the normalized string representations
\end{itemize}

\section{Testing and Validation}
\subsection{Test Design Strategy}
The testing approach employed comprehensive scenarios to validate both detection accuracy and robustness against edge cases. The test methodology included:

\begin{itemize}
    \item \textbf{Positive Test Cases}: Valid plates in various formats and contexts
    \item \textbf{Negative Test Cases}: Invalid patterns that should not match
    \item \textbf{Boundary Test Cases}: Edge scenarios with partial matches and embeddings
    \item \textbf{Performance Test Cases}: Large text documents with multiple plates
    \item \textbf{Consistency Test Cases}: Verification that both approaches yield identical results
\end{itemize}

\subsection{Comprehensive Test Corpus}
A carefully constructed test paragraph was developed containing:
\begin{lstlisting}[frame=single, backgroundcolor=\color{gray!10}, caption=Sample Test Input]
Sample text: "Vehicle AB-1234-E was involved in incident. 
Also present: MN 4321 ZT and UV-9876-T. Invalid cases include 
AAB-1234-T (too many letters), AB-12345-T (too many digits), 
and AB_1234_T (wrong separators). Embedded case NAB-1234-TE 
should not match. Normal text continues..."
\end{lstlisting}

\subsection{Expected vs. Actual Results}
\begin{center}
\begin{tabular}{|l|c|c|}
\hline
\textbf{Test Input} & \textbf{Expected} & \textbf{Both Methods} \\
\hline
\texttt{AB-1234-E} & Match & \checkmark AB-1234-E \\
\texttt{MN 4321 ZT} & Match & \checkmark MN-4321-ZT \\
\texttt{UV-9876-T} & Match & \checkmark UV-9876-T \\
\texttt{AAB-1234-T} & No Match & \checkmark No Match \\
\texttt{AB-12345-T} & No Match & \checkmark No Match \\
\texttt{AB\_1234\_T} & No Match & \checkmark No Match \\
\texttt{NAB-1234-TE} & No Match & \checkmark No Match \\
\hline
\end{tabular}
\end{center}

\subsection{Cross-Validation Testing}
A comparison helper function was implemented to ensure both approaches produce identical results:

\begin{lstlisting}[language=Python, caption=Method Comparison Function]
def compare_detectors(sample_text):
    print("Manual parser result:")
    senegalese_plate_number_detector(sample_text)
    print("\nRegex parser result:")
    detect_senegalese_plates_regex(sample_text)
\end{lstlisting}

\section{Results and Performance Analysis}
\subsection{Detection Accuracy}
Both implementation approaches achieved perfect accuracy on the comprehensive test suite:

\begin{itemize}
    \item \textbf{True Positives}: 100\% of valid plates correctly identified
    \item \textbf{False Positives}: 0\% - no invalid patterns incorrectly detected
    \item \textbf{True Negatives}: 100\% of invalid patterns correctly rejected
    \item \textbf{False Negatives}: 0\% - no valid plates missed
\end{itemize}

\subsection{Output Consistency}
\begin{center}
\begin{tabular}{|l|l|}
\hline
\textbf{Test Input} & \textbf{Normalized Output} \\
\hline
\texttt{"ab-1234-e"} & \texttt{AB-1234-E} \\
\texttt{"AB 5678 CD"} & \texttt{AB-5678-CD} \\
\texttt{"mn-4321-zt"} & \texttt{MN-4321-ZT} \\
\texttt{"UV 9876 t"} & \texttt{UV-9876-T} \\
\hline
\end{tabular}
\end{center}

\subsection{Performance Characteristics}
\subsubsection{Algorithmic Complexity}
\begin{itemize}
    \item \textbf{Manual Parser}: O(n) where n is text length, with constant-time validation per position
    \item \textbf{Regex Engine}: O(n) with optimized pattern matching, typically faster in practice
    \item \textbf{Memory Usage}: O(k) where k is the number of unique plates detected
\end{itemize}

\section{Conclusion}
\subsection{Project Summary}
This project successfully demonstrated two complementary approaches to automated license plate detection in unstructured text documents. Both the manual character-by-character parsing method and the regular expression-based approach achieved perfect accuracy in detecting Senegalese license plate patterns while maintaining zero false positive rates.

\subsection{Key Achievements}
\begin{itemize}
    \item \textbf{Dual Implementation Strategy}: Successfully developed and validated two distinct algorithmic approaches
    \item \textbf{Perfect Accuracy}: Achieved 100\% precision and recall on comprehensive test suites
    \item \textbf{Robust Validation}: Implemented thorough boundary checking and pattern validation
    \item \textbf{Standardized Output}: Ensured consistent formatting regardless of input variations
    \item \textbf{Cross-Method Validation}: Confirmed identical results between both approaches
\end{itemize}

\subsection{Technical Contributions}
\subsubsection{Algorithm Design}
\begin{itemize}
    \item Developed explicit state machine for manual parsing with clear validation steps
    \item Constructed optimized regular expression with comprehensive boundary assertions
    \item Implemented efficient duplicate detection and order preservation mechanisms
    \item Created robust error handling for edge cases and invalid inputs
\end{itemize}

\subsection{Educational Value}
This project serves as an excellent demonstration of:
\begin{itemize}
    \item \textbf{Algorithm Comparison}: Contrasting explicit algorithmic approaches with pattern matching
    \item \textbf{Text Processing Techniques}: Practical application of string manipulation and validation
    \item \textbf{Regular Expression Design}: Construction and optimization of complex regex patterns
    \item \textbf{Software Testing}: Comprehensive validation and cross-method verification
\end{itemize}

\subsection{Practical Utility}
The developed system provides immediate practical value for:
\begin{itemize}
    \item \textbf{Document Processing}: Automated extraction from various text sources
    \item \textbf{Data Standardization}: Normalization of license plate formats in databases
    \item \textbf{Research Applications}: Foundation for traffic and transportation studies
    \item \textbf{System Integration}: Component for larger document analysis pipelines
\end{itemize}

\subsection{Final Assessment}
Both implementation approaches successfully meet the project objectives of clarity, correctness, and ease of understanding. The manual parsing method excels in educational transparency and modification flexibility, while the regular expression approach provides operational efficiency and industry-standard pattern matching. Together, they demonstrate the value of multiple solution strategies in software development and provide users with optimal choices based on their specific requirements and constraints.

The project conclusively demonstrates that systematic algorithm design, comprehensive testing, and thoughtful implementation can produce robust, reliable solutions for real-world text processing challenges.
\end{document}
